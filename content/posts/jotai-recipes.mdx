---
title: 'Jotai Recipes I Commonly Use for my Project'
description: 'To read and modify state on our application with Jotai, we need to use paradigm called Recipes, now lets see how we can utilize those terms to read and modify our state with Jotai'
publishedAt: '09/29/2023'
tags: ['react.js', 'jotai']
status: 'draft'
keywords:
  ['react', 'jotai', 'hooks', 'recipes', 'state', 'state manager', 'state management']
  # some comment to fix
---

## Introduction

Jotai takes an atomic approach to global React state management. By combining atoms and renders are automatically optimized based on atom dependency.

This solves the extra re-render issue of React context, eliminates the need for memoization, and provides a similar developer experience to signals while maintaining a **_declarative programming model_**.

> If you don't know about Jotai, I have a [blog post about jotai](https://rizkicitra.dev/blog/jotai-awesome-state-management) explained you can read, feel free to check it out!

To update a state with Jotai, I can simply use built-in Jotai `setter` like so:

```tsx showLineNumbers title="App.tsx"
import { atom, useAtom } from 'jotai'

const atomFruit = atom('mango')

export default function App() {
  const [fruit, setFruit] = useAtom(atomFruit)

  return <button onClick={() => setFruit('orange')}>{fruit}</button>
}
```

Just a basic usage with Jotai, pretty simple.

## Derived Value

Before coming to know what _Recipes_ are in Jotai, we first should know about a derived or computed value.

A derived or computed value is a value obtained from other existing value through some logic, transformation, or calculation.

In programming, a derived or computed values are often used to simplify code, it used to encapsulate logic, and make data manipulation based on existing value to be more convenient.

```tsx title="App.tsx" showLineNumbers
export default function App() {
  const { user } = useUser()
  const isUserAdmin = user.role === 'admin'

  if (isUserAdmin) {
    return <p>You are admin</p>
  }

  return <p>Just a normal user</p>
}
```

In the above example we check wether the user is admin or not, if it's admin, the component simply render **"You are admin"**, otherwise it render **"Just a normal user"**.

The condition to render different UI to the client is by using a derived value `isUserAdmin`.

Oh wow! we already use a `derived` value here.

## Derived Atoms

Let's move on to derived atoms. Derived atoms are just same as the previous one, we just need to see what the previous values are, and then make some magic to process with the current logic or calculation.

```ts title="@/store/atom.ts" showLineNumbers
import { atom } from 'jotai'

type TUserRole = 'admin' | 'user'
type TUser = {
  name: string
  role: Role
}

const userAtom = atom<TUser>({ name: 'Rizki', role: 'user' })

const isUserAdminAtom = atom((get) => get(userAtom).role === 'admin')
```

The above example shows how to create a derived value from the previous atom, very similiar from what we wrote before with `React.useState`.

In Jotai, It's called recipes, we can compose atoms to another atoms, or create an atoms based on the previous atoms to make a new value or atom.

Jotai allows to create these derived values using a declarative approach and without needing to explicitly manage complex state relationships.

## Recipes

Recipes are just derived atoms, a derived atoms usually consist of two principle.

A `read-only` atom takes another atom as input and transforms its value through a calculation performed by a function. This changed value can be used to indicate a computation or modification of the value of the original atom as a derived value.

A `write-only` atoms serve the purpose of accepting new values through writing mechanisms, like `callbacks`. These new values can then be used to trigger specific actions or update an atom in your `write-only` atom.

Now you know about these terms, let's create some recipes.

### 1. String Recipes

A string recipes usually a `read-only` atoms. Where you take a string atoms to be transformed to a new string value.

```ts title="@/store/atom/string.ts" showLineNumbers
export const uppercaseTextAtom = (atomString: Atom<string>) => {
  return atom((get) => get(atomString).toUpperCase())
}
```

### 2. Number Recipes

Who loves math? you're probably not one of.

```ts title="@/store/atom/number.ts" showLineNumbers
export const addAtoms = (num: Atom<string>) => atom((get) => get(num) + 1)
```

### 3. Array Recipes

Let's start with basic recipes, we have a list of arrays, the arrays should be filtered based on user input.

> Wait, that's a search feature?

Yes, you got it right, and without any further explanation. Let's go.

```ts title="@/store/atom.ts" showLineNumbers
import { clearString } from '@/utils/clearString'

import { atom } from 'jotai'

export const inputAtom = atom('')
export const foodsAtom = atom([])
export const filteredFoodsAtom = atom((get) => {
  const search = get(inputAtom)
  const foods = get(foodsAtom)

  if (search === '') return foods
  return foods.filter((food) => {
    return food.name
      .toLowerCase()
      .replace(/\s+/g, '')
      .includes(search.toLowerCase().replace(/\s+/g, ''))
  })
})
```

That being said, the `filteredFoodsAtom` will filter out the `foodsAtom` based on the `inputAtom` value user provided.

That is too verbose, I can actually create a _`pure function`_ to clear the string.

```ts title="@/util/clearstring"
export const clearString = (s: string) => s.toLowerCase().replace(/\s+/g, '')
```

Now, let's refactor our `filteredFoodsAtom`.

```ts {12-16} title="@/store/atom.ts" showLineNumbers
import { clearString } from '@/utils/clearString'

import { atom } from 'jotai'

export const inputAtom = atom('')
export const foodsAtom = atom([])
export const filteredFoodsAtom = atom((get) => {
  const search = get(inputAtom)
  const foods = get(foodsAtom)

  if (search === '') return foods
  return foods.filter((food) => {
    const clearSearch = clearString(search)
    const clearName = clearString(food.name)
    return clearName.includes(clearSearch)
  })
})
```

Another example is to sort an array, array recipes in Jotai is just like a regular declarative way to mutat your data.

Sorting a list of array in an atoms is easy, just like previous example, we just need to sorted it out.

```ts title="@/store/atom.ts" showLineNumbers
import { compareDesc } from 'date-fns'
import { atom } from 'jotai'

export const postAtoms = atom([])

export const latestPostAtoms = atom((get) => {
  const posts = get(postAtoms)

  return posts.slice(0).sort((a, b) => compareDesc(a, b))
})
```

With that being said, mutating array states are pretty neat right?
